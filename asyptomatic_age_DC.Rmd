---
output: html_document
---


#### COVID-19 Transmission in Washington, DC  

Guide for running and interpreting SEAIR model results

Updated `r Sys.Date()`

Prepared by: Alex Becker, Sophie Berube, Kyra Grantz, Sonia Hegde, Forrest Jones, Amy Wesolowski


 -------------------------------

#### Dependencies

Note that version numbers provided are recommendations; code may run with different versions but results have not been verified

 - R 			version >= 3.6.1  
 - `socialmixr`		version 0.1.6  
 - `magrittr`		version 1.5  
 - `stringr`			version 1.4  
 - `reshape2`		version 1.4.3  
 - `dplyr`			version 0.83  
 - `ggplot2`		version 3.2.1  
 - `truncnorm`    version 1.0.8
 

```{r setup, include=FALSE}

  require(socialmixr)
  require(magrittr)
  require(stringr)
  require(reshape2)
  require(dplyr)
  require(ggplot2)
  require(truncnorm)

```


 -------------------------------

#### Data Input

Currently, the only required data input for this model is `Washington_AgePopulation.csv`, a CSV file with the total population size (row 1) and population size in various age bins. The directory and file name are fed into the `setup_seir_model` function.

 -------------------------------

#### Functions

This document has 5 different functions to (1) clean up the age structured data, (2) make a mixing matrix, (3) rescale the mixing matrix, (4) run the discrete time simulation, and (5) set up all of the parameters/etc. for the discrete time simulation.

(1) `make_age_structure_matrix`

This function cleans the age structured demographic data sourced from `age_data_file`. This code assumes that the first row of `age_data_file` will be the total population and the following rows are the ages broken down by age groups.

The function also adds a certain number of homeless individuals (`homeless_n`) and healthcare workers (`healthcare_n`) as separate compartments. If you do not want to include homeless or healthcare workers, just set these values to zero. This function assumes that the addition of healthcare workers and homeless does not decrease from their respective age groups; that is, any homeless or healthcare workers included in the model are in addition to the number of individuals in `age_data_file`.

This function returns `Ncomp`, the number of age/healthcare worker/homeless categories included in the model, and `DC_pop`, the number of individuals in each age/other categories

```{r make_age_structure_matrix}

  make_age_structure_matrix <- function(age_data_file, homeless_n, healthcare_n){
    ## Pull out population data, removing total population row
    n_age_classes <- nrow(age_data_file)-1
    DC_pop <- age_data_file[2:nrow(age_data_file),]$Estimate
    
    ## aggregate the data such that oldest class is 75 and up
    ## this is to match with the socialmixr matrix
    DC_pop[(n_age_classes-2)] <- DC_pop[(n_age_classes-2)] + DC_pop[(n_age_classes-1)] + DC_pop[n_age_classes]
    DC_pop <- DC_pop[1:(n_age_classes-2)]
    DC_pop = c(DC_pop, healthcare_n) ## healthcare workers
    DC_pop = c(DC_pop, homeless_n) ## number homeless
    
    Ncomp <- length(DC_pop) 
    return(list(Ncomp = Ncomp, DC_pop = DC_pop))  
  }

```

 -------------------------------


(2) `make_polymod_matrix`

The [Polymod study](https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0050074) is one of the foremost studies of human contact patterns relevant to infectious disease spread.

This function sets up a matrix using POLYMOD data from the UK (there is no US data). It will make a mixing matrix set up for all of the different age classes (parameterizing the relative intensity of pairwise contact between age groups and the homeless and healthcare worker populations). 

This function requires input:

- `age.limits`, a vector of the lower limit of each age category to use. Note that this code will combine all age categories >75y into a single age category. Hence Ncomp != length(age.limits) + 2.

- `hcw.mix` and `hml.mix`, character string of the age category to use to approximate healthcare worker (`hcw.mix`) and homeless mixing patterns (`hml.mix`). Here, we have assumed that the the mixing patterns for the 45-49y age group approximate those of the healthcare workers and homeless individuals. `hcw_mix` and `hml.mix` should be formatted as `"min_age,max_age+1"`, e.g., `"45,50"`.

This function returns `W`, the contact matrix for each category included in the model.

```{r make_polymod_matrix}

  age.limits = seq(0, 85, 5)

  make_polymod_matrix <- function(age.limits, hcw.mix="45,50", hml.mix="45,50"){
    ## setup polymod matrix
    ## use age classes in the data
    ## for now, hard code it into the function, but can change later
    ## use the UK mixing pattern as I don't believe US is available
    data(polymod)
    age_mix <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age.limits)$matrix
    
    ## assumes homeless and healthcare workers have the same mixing as 45-49 year olds
    W <- matrix(NA,nrow(age_mix)+2, ncol(age_mix)+2)
    
    rownames(W) <- c(rownames(age_mix), 'healthcare', 'homeless')
    colnames(W) <- c(colnames(age_mix), 'healthcare', 'homeless')
    W[1:nrow(age_mix),1:ncol(age_mix)] <- age_mix
    
    
    W[nrow(age_mix)+1,] = W[grep(hcw.mix, rownames(W)),] ## healthcare
    W[nrow(age_mix)+2,] = W[grep(hml.mix, rownames(W)),] ## homeless
    W[,nrow(age_mix)+1] = W[,grep(hcw.mix, rownames(W))] ## healthcare
    W[,nrow(age_mix)+2] = W[,grep(hml.mix, rownames(W))] ## homeless
    return(W)
  }

```

 -------------------------------


(3) `rescale_age_matrix`

We need to rescale the mixing matrix to ensure that $R_0 = \frac{\beta}{\gamma}$. This requires that the maximum eigenvalue of our input matrix to be 1. [This reference](http://www.sherrytowers.com/towers_feng_2012.pdf) (pg. 242) provides the formula for R0 calculations for age structured matrix models. 

This function requires four inputs: 

- `Ncomp`, the number of age/other categories used in the model

- `W`, the mixing matrix created by `make_polymod_matrix`

- `DC_pop`, the cleaned population object created by `make_age_structure_matrix`

- `c_scale_vec`, a vector of length `Ncomp`, which can be used to rescale the contact rates for healthcare workers (and other categories), as necessary. When `c_scale_vec = 1`, there is no rescaling. Note that this increases contacts between compartment *i* and all other compartments; it cannot be used, e.g., to increase only child-child contacts without also increasing child-adult contacts.

The function returns `W`, the rescaled contact matrix, and `C`, a rescaling matrix that can be used to implement changes to rescale healthcare worker contact rates.

```{r rescale_age_matrix}

rescale_age_matrix <- function(Ncomp, W, DC_pop, c_scale_vec){
  A <- matrix(0,Ncomp,Ncomp)
  for (ii in 1:Ncomp){
    for (jj in 1:Ncomp){
      A[ii,jj] <- W[ii,jj]*DC_pop[ii]/DC_pop[jj]
    }
  }
  ## compute spectral radius / scaling parameter
  r <- eigen(A)
  lam <- r$values
  alpha <- max(Re(lam))
  W <- W / alpha
  ## now the matrix is rescaled have R0  = 1, so beta0 can be scaled to be real transmission
  C <- matrix(c_scale_vec,nrow(W),ncol(W)) ## a special contact matrix to be used to rescale health facility worker contact rates - when set to 1, it is turned off 
  return(list(W = W, C = C))
}

```


 -------------------------------

(4) `setup_seir_model`

This function is the only function which should require edits. This function serves as a wrapper function, incorporating the three functions above (`make_age_structure_matrix`, `make_polymod_matrix`, `rescale_mixing`. It returns output with all parameters needed to run the transmission model. Several of these values need to be directly defined in the function arguments below.

Note that this same function is used to run the initial setup for `sair_step_variableR0`, which allows both `R0` and `c_scale_vec` to change over time. The `R0`output of this function will **not** be used in the model runs; rather, R0 will be recalculated in the `sair_step_variableR0` funtcion at each time point. If `c_scale_mat` is specified as an argument in `sair_step_variableR0`, then `c_scale_vec` and `C` from this function will be ignored. Similarly, the `ICs` output from this function will ignored in `sair_step` and `sair_step_variableR0` if `stoch.init=TRUE`.


Inputs to `setup_seir_model`:

- `stoch`: binary TRUE/FALSE for whether there should be stochasticity added to the force of infection for each age category, at each time point

- `R0`: the basic reproductive number of our model

- `c_scale_vec`, a vector of length `Ncomp`, which can be used to rescale the contact rates for healthcare workers (and other categories), as necessary. Defaults to 1, meaning no rescaling for any compartments. Note that this increases contacts between compartment *i* and all other compartments; it cannot be used, e.g., to increase only child-child contacts without also increasing child-adult contacts.

- `gamma` - the rate of recovering once infectious; here, set to be 1/6.5d

- `sigma` - the rate of becoming infectious following exposure to SARS-CoV-2; here, set to be 1/5.2d

- `prop_symptomatic` - the proportion of infections assumed to develop symptoms; here, set to be 0.2.

- `beta1` - the amplitude of the seasonal forcing function for $\beta_t$; here, equal to 0, removing seasonal forcing from the model.

- `phase` - $a$, or the phase in the seasonal forcing function for $\beta_t$

- `mu` - the birth rate in the population; here, set to be 0

- `v` - the natural death rate in the population; here, set to be 0

- `sd.dw` - the standard deviation for the stochasticity added to event rates at each time step; here, set to be 0.05

- `hcw.mix` - the input to `make_polymod_matrix` which determines mixing patterns of healthcare workers

- `hml.mix` - the input to `make_polymod_matrix` which determines mixing patterns of homeless

- `homeless_n` - the input to `age_data`, the function to clean the population data, to add homeless population; set to 2000 by default

- `healthcare_n` - the input to `age_data`, the function to clean the population data, to add healthcare worker population; set to 5000 by default



This function returns a list with objects:

- `C` - the rescaled mixing matrix created by `rescale_age_matrix`

- `W` - the mixing matrix created by `rescale_age_matrix`

- `beta0` - the intercept, or baseline infectiousness, of the seasonal forcing function for $\beta_t$; a function of `R0`, `gamma`, `sigma`, and `v`.

- `beta1` - the amplitude of the seasonal forcing function for $\beta_t$; here, equal to 0, removing seasonal forcing from the model.

- `phase` - $a$, or the phase in the seasonal forcing function for $\beta_t$

- `mu` - the birth rate in the population; here, set to be 0

- `v` - the natural death rate in the population; here, set to be 0

- `ICs` - The initial condition to start the model run, as a vector with number of individuals in each category. Here, we begin the model with 8 asymptomatically infected individuals and 2 symptomatically infected individuals in each age/other category.

- `Ncomp` - the number of age/other categories used in the model

- `N` - a vector of the population size in each age/other category

- `gamma` - the rate of recovering once infectious; here, set to be 1/6.5d

- `sigma` - the rate of becoming infectious following exposure to SARS-CoV-2; here, set to be 1/5.2d

- `prop_symptomatic` - a vector for the age/class-specific proportion of infections assumed to develop symptoms; we use data from [this report ](https://cmmid.github.io/topics/covid19/current-patterns-transmission/age_hypotheses.html). We assume again that HCW and homeless have the same proportion of symptomatic infection as those who are 45 - 49y of age.


```{r setup_seir_model}
setup_seir_model <- function(stoch, R0, c_scale_vec=1,
                             gamma=1/6.5, sigma=1/5.2,
                             phase=0, beta1=0, mu=0, v=0,
                             prop_symptomatic, sd.dw=0.05,
                             hcw.mix="45,50", hml.mix="45,50",
                             homeless_n=2000, healthcare_n=5000){
  
  data <- read.csv('Washington_AgePopulation.csv')
  age_data <- make_age_structure_matrix(data, homeless_n = homeless_n, healthcare_n = healthcare_n)
  DC_pop = age_data$DC_pop
  Ncomp = age_data$Ncomp
  W <- make_polymod_matrix(age.limits, hcw.mix = hcw.mix, hml.mix = hml.mix)
  rescale_mixing <- rescale_age_matrix(Ncomp, W, DC_pop, c_scale_vec)
  W <- rescale_mixing$W
  C <- rescale_mixing$C
  
    
  ## set prop_symtomatic
  prop_symptomatic <- prop_symptomatic
  if(length(prop_symptomatic)!=Ncomp){warning("prop_symptomatic is the wrong length")}
  

  ICs <- c(S = DC_pop * 1, 
           E = rep(0,length(DC_pop)),
           A = rep(8,length(DC_pop)),
           I = rep(2,length(DC_pop)), 
           R = DC_pop,
           incid_A = rep(0,Ncomp),
           incid_I = rep(0,Ncomp))
  
  ## set the R compartment
  ## crudely just set anything negative to be zero but we can fine tune this more depending on what we assume S0 does
  ICs[(4*Ncomp+1):(5*Ncomp)] <- DC_pop -  ICs[1:Ncomp] - ICs[(Ncomp+1):(2*Ncomp)] - ICs[(2*Ncomp+1):(3*Ncomp)] - ICs[(3*Ncomp+1):(4*Ncomp)]
  ICs[(4*Ncomp+1):(5*Ncomp)] [ICs[(4*Ncomp+1):(5*Ncomp)]  < 0 ] <- 0
  
  ## population sizes by demographic data
  N <- DC_pop         
  
  ## units in days!! 
  gamma <- gamma ## infectious period
  sigma <- sigma ## latent period
  phase <- phase ## when should seasonal forcing peak?
  mu <- mu ## set births to be zero currently
  v <- v ## set natural death rate to be zero currently
  #R0 <- 2.5 ## make a range?   ## R0 = beta * sigma / ((sigma + v) * (v + gamma)) for SEAIR model with split proportion into A-I and only A and I contributing to infection
  beta0 <- R0 * (gamma + v) * (sigma + v) / sigma ## set beta based on that value
  beta1 <- beta1 ## seasonal forcing should be modest here
  sd.dw <- sd.dw
  
  ## now check to make sure the R0 we get is the R0 we put in
  ## using the same formula as above
  R0.mat <- matrix(0,Ncomp,Ncomp)
  for (i in 1:Ncomp){
    for (j in 1:Ncomp){
      R0.mat[i,j] <- W[i,j]*DC_pop[i]/DC_pop[j]* beta0 * sigma / ( (sigma + v) * (v + gamma))
    }
  }
  # 
  # for (i in 1:Ncomp){
  #   for (j in 1:Ncomp){
  #     R0.mat[i,j] <- W[i,j]*DC_pop[i]/DC_pop[j]* beta0 * (gamma + v) * (sigma +v )/sigma
  #   }
  # }
  print(eigen(R0.mat)$values[1]) ## just a check
  return(list(C = C, W = W, 
              beta0 = beta0, beta1 = beta1, 
              phase = phase, mu = mu, v = v, ICs = ICs, 
              Ncomp = Ncomp, N=N, gamma=gamma, sd.dw=sd.dw,
              sigma = sigma, prop_symptomatic=prop_symptomatic))
}


```

 -------------------------------

(5) `sair_step`

This is the critical function which runs the SEAIR model. It requires the following inputs:

- `stoch`: binary TRUE/FALSE for whether there should be stochasticity added to the force of infection for each age category, at each time point

- `stoch.init`: binary TRUE/FALSE for whether the initial conditions should be randomly drawn, and therefore varied between simulations (even when given the same `ICs` argument)

- `Ncomp`: the number of age/other categories used in the model. Can be pulled from the output of `setup_seir_model`

- `ICs`: The initial condition to start the model run, as a vector with number of individuals in each category. Can be pulled from the output of `setup_seir_model`.

- `params`: a list of parameter values and objects, generated by the `setup_seir_model` model. Code is provided below to generate a list from the output of `setup_seir_model`.

- `time`: the sequence of time-steps over which to run the model (e.g., `time <- seq(0, 300, delta.t)`)

- `delta.t`: the time-step to use in the model; we recommend using at least daily time-steps, if not finer granularity

- `init.min`: the minimum number of infected individuals at t=0; only used if `stoch.init=TRUE`

- `init.max`: the maximum number of infected individuals at t=0; only used if `stoch.init=TRUE`

- `init.dist`: a vector of length `Ncomp` giving the relative number of initial infections (in absolute numbers - **not** incidence) in each category If not specified, initial infections will be distributed to categories propotional to population size.

This function returns an object with the number of individuals in each model compartment (SEAIR + incidA (incident asymptomatic cases) + incidI (incident infectious cases)), per time point, per age-category+homeless+healthcare workers.

```{r sair_step}

sair_step <- function(stoch = F, stoch.init = F, Ncomp, ICs, params, time, delta.t, init.min = 10, init.max=60, init.dist = NULL){
  C = params$C
  W = params$W
  beta0 = params$beta0
  beta1 = params$beta1
  phase = params$phase
  mu = params$mu
  v = params$v
  N=params$N
  sigma = params$sigma
  gamma=params$gamma
  prop_symptomatic=params$prop_symptomatic
  sd.dw <- params$sd.dw

  ## set up a matrix to store values in by variable and time
  ## each X[it,] is the variable at one hour
  x <- matrix(NA,length(time),Ncomp * 7)
  
  ## set initial conditions
  if(stoch.init){
    Ninit <- sample(init.min:init.max, 1)
    if(is.null(init.dist)){pinit <- N / sum(N)}else{pinit <- init.dist}
    Ninit_byage <- rmultinom(1, Ninit, prob = pinit)[,1]
    Ninit_asy <- round(Ninit_byage * (1-prop_symptomatic))
    Ninit_sym <- Ninit_byage - Ninit_asy
    ICs <- c(S = N, 
             E = rep(0, Ncomp),
             A = Ninit_asy,
             I = Ninit_sym,
             R = rep(0, Ncomp),
             incid_A = rep(0, Ncomp),
             incid_I = rep(0, Ncomp))
    x[1,] <- round(ICs)
    
  }else{ x[1,] <- round(ICs) }

  S <- x[,1:Ncomp]; ## susceptible individuals
  E <- x[,(Ncomp+1):(2*Ncomp)]; ## exposed individuals 
  A <- x[,(2*Ncomp+1):(3*Ncomp)]; ## asymptomatic individuals
  I <- x[,(3*Ncomp+1):(4*Ncomp)];## symp individuals
  R <- x[,(4*Ncomp+1):(5*Ncomp)] ## recovered individuals
  
  ## incidence
  incid_A <- x[,(5*Ncomp+1):(6*Ncomp)]
  incid_I <- x[,(6*Ncomp+1):(7*Ncomp)]
  
  ## seasonal transmission
  seas <- beta0 * (1 + beta1 * cos(2 * pi * time/365 - phase))
  
  for(it in 1:(length(time) - 1)){
    WI <- (C*W)%*%(A[it,] + I[it,])
    
    WI[!is.finite(WI)] <- 0
    births <-rep(0,Ncomp)
    births[1] <- mu
    deaths <- rep(v,Ncomp)
    
    ## add stochasticity to FOI
    if(stoch == T){
      dw <- rtruncnorm(Ncomp, a=0, mean = 1, sd = sd.dw)
    }else{
      dw <- 1
    }
    
    ## declare transitions in model
    foi_prob <- 1 - exp( - seas[it] * WI/N * dw * delta.t)
    exposed_prob <- 1 - exp( - sigma * delta.t)
    inf_prob <- 1 - exp( - gamma * delta.t)
    death_prob <- 1 - exp( - deaths * delta.t)
    
    ## stochastic formulation of the model
    if(stoch == T){
      new_exp <- rbinom(n = Ncomp, size = round(S[it,]), prob = foi_prob)
      new_inf <- rbinom(n = Ncomp, size = round(E[it,]) , prob = exposed_prob)
      new_infA <- round( (1-prop_symptomatic)*new_inf )
      new_infI <- new_inf - new_infA
      new_rec_A <- rbinom(n = Ncomp, size = round(A[it,]), prob = inf_prob)
      new_rec_I <- rbinom(n = Ncomp, size = round(I[it,]), prob = inf_prob)
      
      S[it + 1, ] <- S[it,] +  births*delta.t - new_exp - rbinom(n = Ncomp, size = round(S[it,]), prob = death_prob)
      E[it + 1, ] <- E[it,] +  new_exp - new_inf - rbinom(n = Ncomp, size = round(E[it,]), prob = death_prob )
      A[it + 1, ] <- A[it,] +  new_infA - new_rec_A - rbinom(n = Ncomp, size = round(A[it,]), prob = death_prob)
      I[it + 1, ] <- I[it,] +  new_infI - new_rec_I - rbinom(n = Ncomp, size = round(I[it,]), prob = death_prob)
      R[it + 1, ] <- R[it,] +  new_rec_I + new_rec_A - rbinom(n = Ncomp, size = round(R[it,]), prob = death_prob)
      
      ## make incidence the new number of daily individuals becoming infected
      incid_A[it, ] <- new_infA
      incid_I[it, ] <- new_infI
    }
    
    ## deterministic equations
    if(stoch == F){
      S[it + 1, ] <- S[it,] + delta.t * (births - seas[it] * WI * S[it,] * dw / N  - deaths*S[it,])
      E[it + 1, ] <- E[it,] + delta.t * (seas[it] * WI * S[it,] * dw / N - deaths*E[it,] - sigma*E[it,])
      A[it + 1, ] <- A[it,] + delta.t * ( (1 - prop_symptomatic)*sigma*E[it,]   - A[it,]*(gamma - deaths))
      I[it + 1, ] <- I[it,] + delta.t * (  prop_symptomatic*sigma*E[it,] - I[it,]*(gamma - deaths) )
      R[it + 1, ] <- R[it,] + delta.t * (A[it,]*gamma+ I[it,]*gamma - R[it,]* deaths)
      incid_A[it,] <-  (1 - prop_symptomatic)*(seas[it] * WI * S[it,] * dw / N)
      incid_I[it,] <- prop_symptomatic*(seas[it] * WI * S[it,] * dw / N)
    }
  }
  out <- data.frame(cbind(time,S,E,A,I,R,incid_A, incid_I))
  names(out) <- c('time',names(ICs))
  ## output is the number in each class per time point per age-category+homeless+healthcare workers
  return(out)
}


```

 -------------------------------

(6) `sair_step_variableR0`

This is an adaptation of `sair_step` which allows R0 to vary across time. It requires some input from `setup_sair_model` (run with the first R0 value for t=1), along with `time`, `delta.t`, and a vector of R0 values at each time step:

- `stoch`: binary TRUE/FALSE for whether there should be stochasticity added to the force of infection for each age category, at each time point

- `stoch.init`: binary TRUE/FALSE for whether the initial conditions should be randomly drawn, and therefore varied between simulations (even when given the same `ICs` argument)

- `R0vec`: a vector of the R0 value at each time step in the model. This must have the same length as `time`.

- `Ncomp`: the number of age/other categories used in the model. Can be pulled from the output of `setup_seir_model`

- `ICs`: The initial condition to start the model run, as a vector with number of individuals in each category. Can be pulled from the output of `setup_seir_model`.

- `params`: a list of parameter values and objects, generated by the `setup_seir_model` model run for `R0vec[1]`. Code is provided below to generate a list from the output of `setup_seir_model`. Note that in this function `params$R0` is always ignored, `params$ICs` will be ignored if `stoch.init=TRUE`, and `params$C` will be ignored if `c_scale_mat` is provided.

- `time`: the sequence of time-steps over which to run the model (e.g., `time <- seq(0, 300, delta.t)`)

- `delta.t`: the time-step to use in the model; we recommend using at least daily time-steps, if not finer granularity

- `init.min`: the minimum number of infected individuals at t=0; only used if `stoch.init=TRUE`

- `init.max`: the maximum number of infected individuals at t=0; only used if `stoch.init=TRUE`

- `init.dist`: a vector of length `Ncomp` giving the relative number of initial infections (in absolute numbers - **not** incidence) in each category If not specified, initial infections will be distributed to categories propotional to population size.

- `c_scale_mat`: an OPTIONAL matrix of `c_scale_vec` for each time point (i.e., each row is the c_scale_vec for one time point in the model). If this is not specified, the model will default to using `params$C`, genereted in `setup_sair_model`.

This function returns an object with the number of individuals in each model compartment (SEAIR + incidA (incident asymptomatic cases) + incidI (incident infectious cases)), per time point, per age-category+homeless+healthcare workers.

```{r sair_step_variableR0}

sair_step_variableR0 <- function(stoch = F, stoch.init = F, R0vec, Ncomp, ICs, params, time, delta.t, init.min = 10, init.max=60, init.dist = NULL, c_scale_mat=NULL){
  
  C = params$C
  W = params$W
  beta0 = params$beta0
  beta1 = params$beta1
  phase = params$phase
  mu = params$mu
  v = params$v
  N=params$N
  sigma = params$sigma
  gamma=params$gamma
  prop_symptomatic=params$prop_symptomatic
  sd.dw <- params$sd.dw
  
  ## set up a matrix to store values in by variable and time
  ## each X[it,] is the variable at one hour
  x <- matrix(NA,length(time),Ncomp * 7)
  
  ## set initial conditions
  if(stoch.init){
    Ninit <- sample(init.min:init.max, 1)
    if(is.null(init.dist)){pinit <- N / sum(N)}else{pinit <- init.dist}
    Ninit_byage <- rmultinom(1, Ninit, prob = pinit)[,1]
    Ninit_asy <- round(Ninit_byage * (1-prop_symptomatic))
    Ninit_sym <- Ninit_byage - Ninit_asy
    ICs <- c(S = N, 
             E = rep(0, Ncomp),
             A = Ninit_asy,
             I = Ninit_sym,
             R = rep(0, Ncomp),
             incid_A = rep(0, Ncomp),
             incid_I = rep(0, Ncomp))
    x[1,] <- round(ICs)
    
  }else{ x[1,] <- round(ICs) }
  
  S <- x[,1:Ncomp]; ## susceptible individuals
  E <- x[,(Ncomp+1):(2*Ncomp)]; ## exposed individuals 
  A <- x[,(2*Ncomp+1):(3*Ncomp)]; ## asymptomatic individuals
  I <- x[,(3*Ncomp+1):(4*Ncomp)];## symp individuals
  R <- x[,(4*Ncomp+1):(5*Ncomp)] ## recovered individuals
  
  ## incidence
  incid_A <- x[,(5*Ncomp+1):(6*Ncomp)]
  incid_I <- x[,(6*Ncomp+1):(7*Ncomp)]
  
  # recalculate beta0 for each R0 value
  beta0 <- R0vec * (gamma + v) * (sigma + v) / sigma 
  seas <- beta0 * (1 + beta1 * cos(2 * pi * time/365 - phase))
  R0 <- vector(length=length(time))
  Re <- vector(length=length(time))

  for(it in 1:(length(time) - 1)){
    
    # calculate and store the R0 value for time-specific beta0 - to confirm the new value is correct
    R0.mat <- matrix(0,Ncomp,Ncomp)
    for (i in 1:Ncomp){
       for (j in 1:Ncomp){
          R0.mat[i,j] <- W[i,j]*N[i]/N[j]* beta0[it] * sigma / ( (sigma + v) * (v + gamma))
       }
    }
    R0[it] <- Re(eigen(R0.mat)$values[1])
     
    # proceed with model step, as in sair_step
    # if c_scale_mat is provided, recalculate C matrix
    if(!is.null(c_scale_mat)){
      C <- matrix(c_scale_mat[it,],nrow(W),ncol(W))
    }
    WI <- (C*W)%*%(A[it,] + I[it,])
    WI[!is.finite(WI)] <- 0
    
    # calculate and store the effective R value (if any value of C is non-1)
    if(sum(C!=1)>0){
      Wscal <- C*W
      Re.mat <- matrix(0,Ncomp,Ncomp)
      for (i in 1:Ncomp){
         for (j in 1:Ncomp){
            Re.mat[i,j] <- Wscal[i,j]*N[i]/N[j]* beta0[it] * sigma / ( (sigma + v) * (v + gamma))
         }
      }
      Re[it] <- Re(eigen(Re.mat)$values[1])
    }else{
        Re[it] <- R0[it]
    }
     
    
    births <-rep(0,Ncomp)
    births[1] <- mu
    deaths <- rep(v,Ncomp)
    
    ## add stochasticity to FOI
    if(stoch == T){
      dw <- rtruncnorm(Ncomp, a=0, mean = 1, sd = sd.dw)
    }else{
      dw <- 1
    }
    
    ## declare transitions in model
    foi_prob <- 1 - exp( - seas[it] * WI/N * dw * delta.t)
    exposed_prob <- 1 - exp( - sigma * delta.t)
    inf_prob <- 1 - exp( - gamma * delta.t)
    death_prob <- 1 - exp( - deaths * delta.t)
    
    ## stochastic formulation of the model
    if(stoch == T){
      new_exp <- rbinom(n = Ncomp, size = round(S[it,]), prob = foi_prob)
      new_inf <- rbinom(n = Ncomp, size = round(E[it,]) , prob = exposed_prob)
      new_infA <- round( (1-prop_symptomatic)*new_inf )
      new_infI <- new_inf - new_infA
      new_rec_A <- rbinom(n = Ncomp, size = round(A[it,]), prob = inf_prob)
      new_rec_I <- rbinom(n = Ncomp, size = round(I[it,]), prob = inf_prob)
      
      S[it + 1, ] <- S[it,] +  births*delta.t - new_exp - rbinom(n = Ncomp, size = round(S[it,]), prob = death_prob)
      E[it + 1, ] <- E[it,] +  new_exp - new_inf - rbinom(n = Ncomp, size = round(E[it,]), prob = death_prob )
      A[it + 1, ] <- A[it,] +  new_infA - new_rec_A - rbinom(n = Ncomp, size = round(A[it,]), prob = death_prob)
      I[it + 1, ] <- I[it,] +  new_infI - new_rec_I - rbinom(n = Ncomp, size = round(I[it,]), prob = death_prob)
      R[it + 1, ] <- R[it,] +  new_rec_I + new_rec_A - rbinom(n = Ncomp, size = round(R[it,]), prob = death_prob)
      
      ## make incidence the new number of daily individuals becoming infected
      incid_A[it, ] <- new_infA
      incid_I[it, ] <- new_infI
    }
    
    ## deterministic equations to check -- does not currently work 
    if(stoch == F){
      S[it + 1, ] <- S[it,] + delta.t * (births - seas[it] * WI * S[it,] * dw / N  - deaths*S[it,])
      E[it + 1, ] <- E[it,] + delta.t * (seas[it] * WI * S[it,] * dw / N - deaths*E[it,] - sigma*E[it,])
      A[it + 1, ] <- A[it,] + delta.t * ( (1 - prop_symptomatic)*sigma*E[it,]   - A[it,]*(gamma - deaths))
      I[it + 1, ] <- I[it,] + delta.t * (  prop_symptomatic*sigma*E[it,] - I[it,]*(gamma - deaths) )
      R[it + 1, ] <- R[it,] + delta.t * (A[it,]*gamma+ I[it,]*gamma - R[it,]* deaths)
      incid_A[it,] <-  (1 - prop_symptomatic)*(seas[it] * WI * S[it,] * dw / N)
      incid_I[it,] <- prop_symptomatic*(seas[it] * WI * S[it,] * dw / N)
    }
  }
  
  out <- data.frame(cbind(time,S,E,A,I,R,incid_A, incid_I,R0, Re))
  names(out) <- c('time',names(ICs),"R0", "Reff")
  ## output is the number in each class per time point per age-category+homeless+healthcare workers
  return(out)
  
}
  
  


```


 -------------------------------

#### Setting up a model run - constant R0

First, run the `setup_seir_model` function to produce the necessary parameters and data input for the model. It should print out the correct $R_0$ value. If not, confirm the correct inputs to the `setup_seir_model` function. A reminder that `age.limits` is the lower limit of each age category in the raw population data; the age categories included in this model will combine all age categories >75y into a single category.

```{r initial_run R0}
  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = 3.0, c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
  ## what is printed should be R0 
```

Next, create the parameter object to read into the `sair_step` function and to set up the time vector across which to run the model.

```{r initial_run time}

  # Assuming here a 1 day time step and a model run for 300 days
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  
  # setting up the parameter, Ncomp, and ICs values for input into sair_step
  Ncomp = all_prelim_info$Ncomp
  ICs = all_prelim_info$ICs
  params = list(C = all_prelim_info$C, 
                W = all_prelim_info$W, 
                beta0 = all_prelim_info$beta0, 
                beta1 = all_prelim_info$beta1, 
                phase = all_prelim_info$phase, 
                mu = all_prelim_info$mu, 
                v = all_prelim_info$v, 
                N=all_prelim_info$N, 
                gamma=all_prelim_info$gamma, 
                sigma = all_prelim_info$sigma, 
                prop_symptomatic=all_prelim_info$prop_symptomatic,
                sd.dw = all_prelim_info$sd.dw)

```


 -------------------------------

#### Running a single simulation and exploring output - constant R0

Now, we use these input to run a single, stochastic iteration of the model with the inputs defined above.

```{r sim1}
  single.sim <- sair_step(stoch = TRUE, stoch.init=F, Ncomp, ICs, params, time, delta.t)

```


```{r sim1_exploration}

  single.sim %>% ggplot(aes(time,I5))+geom_line()+ggtitle("Daily infectious cases, 20-25y")

  # sum the total number of infectious individuals, incident symptomatic infections, and incident asymptomatic infections at each time point across all categories
  single.sim %>% dplyr::select(paste0('I',1:Ncomp)) %>% rowSums() -> totalI
  single.sim %>% dplyr::select(paste0('incid_I',1:Ncomp)) %>% rowSums() -> totalincid_I
  single.sim %>% dplyr::select(paste0('incid_A',1:Ncomp)) %>% rowSums() -> totalincid_A
  
  # combined these into a dataframe and plot incidence asymptomatic and infectious cases
  single.sim <- cbind(single.sim, totalincid_A)
  single.sim <- cbind(single.sim, totalincid_I)
  par(mfrow=c(1,2))
  plot(single.sim$totalincid_A,type='l', ylab="Incident asymptomatic infections")
  plot(single.sim$totalincid_I,type='l', ylab="Incident symptomatic infections")

```

 -------------------------------

#### Running multiple simulations - constant R0

For the sake of preparing this document, the code below will not run, but provides the structure for running more than one simulation at a time. Note that the stochasticity has been increased here (`sd.dw=0.2`).

```{r multiple_sim, eval=FALSE}
  # setup functions
  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = 2.5, c_scale_vec = 1, prop_symptomatic = prop_symptomatic, sd.dw=0.2)
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  Ncomp = all_prelim_info$Ncomp
  ICs = all_prelim_info$ICs
  params = list(C = all_prelim_info$C, 
                W = all_prelim_info$W, 
                beta0 = all_prelim_info$beta0, 
                beta1 = all_prelim_info$beta1, 
                phase = all_prelim_info$phase, 
                mu = all_prelim_info$mu, 
                v = all_prelim_info$v, 
                N=all_prelim_info$N, 
                gamma=all_prelim_info$gamma, 
                sigma = all_prelim_info$sigma, 
                prop_symptomatic=all_prelim_info$prop_symptomatic,
                sd.dw = all_prelim_info$sd.dw)

  # Multiple simulation setup
  nsim <- 50
  all_sim <- matrix(NA,1,(Ncomp*7)+2)
  
  colnames(all_sim) <- c('run_index', 'time',
                         paste0("S", 1:Ncomp),
                         paste0("E", 1:Ncomp),
                         paste0("A", 1:Ncomp),
                         paste0("I", 1:Ncomp),
                         paste0("R", 1:Ncomp),
                         paste0("incid_A", 1:Ncomp),
                         paste0("incid_I", 1:Ncomp))
  
  for(n in 1:nsim){
    ## run the simulation one time
    single.sim <- sair_step(stoch = TRUE, stoch.init = TRUE, Ncomp, ICs, params, time, delta.t)
    #add on a value for the run_index (simulation number)
    run_index = rep(n, nrow(single.sim))
    single.sim <- cbind(run_index, single.sim)
    all_sim <- rbind(all_sim, single.sim)
  }
  all_sim <- all_sim[-1,]
  # write.csv(all_sim, file = 'filename.csv')

  # code to test and plot simulations
  xx <- all_sim %>% select(starts_with("incid_I")) %>% rowSums()
  xx <- cbind(xx, all_sim%>%select(run_index, time))
  ggplot(xx, aes(x=time, y=xx, group=run_index)) + geom_line(alpha=0.3)
  
```


We can also run multiple simulations across multiple values of a constant R0 simultaneously.

```{r multiple_sim multiple_R0, eval=FALSE}
  
  r0_values <- c(1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5)
  write_output_files <- FALSE
  
  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = 2.0, c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  Ncomp = all_prelim_info$Ncomp
  
  for(ii in 1:length(r0_values)){
    
      R0_test = r0_values[ii]
      c_test = 1
      print(R0_test)
      
      nsim <- 500
      all_sim <- matrix(NA,1,(Ncomp*7)+3)
      colnames(all_sim) <- c('R0', 'run_index', 'time',
                             paste0("S", 1:Ncomp),
                             paste0("E", 1:Ncomp),
                             paste0("A", 1:Ncomp),
                             paste0("I", 1:Ncomp),
                             paste0("R", 1:Ncomp),
                             paste0("incid_A", 1:Ncomp),
                             paste0("incid_I", 1:Ncomp))
  
      all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = R0_test, c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
      params = list(C = all_prelim_info$C, 
                    W = all_prelim_info$W, 
                    beta0 = all_prelim_info$beta0, 
                    beta1 = all_prelim_info$beta1, 
                    phase = all_prelim_info$phase, 
                    mu = all_prelim_info$mu, 
                    v = all_prelim_info$v, 
                    N=all_prelim_info$N, 
                    gamma=all_prelim_info$gamma,
                    prop_symptomatic=all_prelim_info$prop_symptomatic, 
                    sigma = all_prelim_info$sigma,
                    sd.dw = all_prelim_info$sd.dw)
      
      for(n in 1:nsim){
        single.sim <- sair_step(stoch = TRUE, stoch.init = FALSE, Ncomp, ICs, params, time, delta.t)
        run_index = rep(n, nrow(single.sim))
        r0_index = rep(R0_test, nrow(single.sim))
        single.sim <- cbind(run_index, single.sim)
        single.sim <- cbind(R0=r0_index, single.sim)
        all_sim <- rbind(all_sim, single.sim)
      }
      all_sim <- all_sim[-1,]
      
      if(write_output_files == TRUE){
        write.csv(all_sim, file = paste(paste(paste('Output_20200322/SEIR_results__n500__r0', R0_test*10, sep = ''), c_test*100, sep = '__'), 'csv', sep = '.'))
      }
      
  }


```

 -------------------------------

#### Setting up a model run - variable R0

This functions requires a nearly identical setup as `sair_step`. The key differences are:

- Must provide `R0vec`, a vector of the same length as `time` which contains the R0 value at each time step.

- Optionally, can provide `c_scale_mat`, a matrix of `c_scale_vec` at each time point, with the same number of rows as `length(time)`. If this matrix is not applied, it is assumed that that a constant `c_scale_vec` defined in `all_prelim_info` applies to each time step.


```{r initial_run variable R0}
  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  
  R0vec <- rep(3, length(time))
  R0vec[31:90] <- 1.7
  R0vec[91:120] <- 2.2
  
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = R0vec[1], c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
  Ncomp = all_prelim_info$Ncomp
  ICs = all_prelim_info$ICs
  params = list(C = all_prelim_info$C, 
                W = all_prelim_info$W, 
                beta0 = all_prelim_info$beta0, 
                beta1 = all_prelim_info$beta1, 
                phase = all_prelim_info$phase, 
                mu = all_prelim_info$mu, 
                v = all_prelim_info$v, 
                N=all_prelim_info$N, 
                gamma=all_prelim_info$gamma, 
                sigma = all_prelim_info$sigma, 
                prop_symptomatic=all_prelim_info$prop_symptomatic,
                sd.dw = all_prelim_info$sd.dw)

  
  single.sim.varR0 <- sair_step_variableR0(stoch = TRUE, stoch.init=TRUE, R0vec, Ncomp, ICs, params, time, delta.t)
  single.sim.varR0 %>% dplyr::select(paste0('I',1:Ncomp)) %>% rowSums() -> totalI
  plot(as.numeric(totalI), type='l')
  
```

The structure to loop across many iteractions of the variable R0 function is very similar to the structure for the constant R0 function. The key difference is that the variable R0 function automatically outputs R0 and Reff and, therefore, you do not need to manually add an R0 column to the `all_sim` object. This code shows how to repeat the variable R0 simulation `nsim` times, where the R0 vector is randomly drawn for each simulation to be a constant R0 between 1.5 and 2.5.


```{r multiple_sim variable R0, eval=FALSE}

  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = 2, c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
  Ncomp = all_prelim_info$Ncomp
  ICs = all_prelim_info$ICs
  params = list(C = all_prelim_info$C, 
                W = all_prelim_info$W, 
                beta0 = all_prelim_info$beta0, 
                beta1 = all_prelim_info$beta1, 
                phase = all_prelim_info$phase, 
                mu = all_prelim_info$mu, 
                v = all_prelim_info$v, 
                N=all_prelim_info$N, 
                gamma=all_prelim_info$gamma, 
                sigma = all_prelim_info$sigma, 
                prop_symptomatic=all_prelim_info$prop_symptomatic,
                sd.dw = all_prelim_info$sd.dw)
  
  all_sim <- matrix(NA,1,(Ncomp*7)+4)
  colnames(all_sim) <- c('run_index', 'time',
                         paste0("S", 1:Ncomp),
                         paste0("E", 1:Ncomp),
                         paste0("A", 1:Ncomp),
                         paste0("I", 1:Ncomp),
                         paste0("R", 1:Ncomp),
                         paste0("incid_A", 1:Ncomp),
                         paste0("incid_I", 1:Ncomp),
                         "R0",
                         "Reff")
  nsim <- 10
  
  for(n in 1:nsim){
    R0vec <- runif(length(time), min = 1.5, max = 2.5)
    tmp <- sair_step_variableR0(stoch = TRUE, stoch.init = TRUE, 
                                R0vec, Ncomp, ICs, params, time, delta.t)
    run_index = rep(n, nrow(tmp))
    tmp <- cbind(run_index, tmp)
    all_sim <- rbind(all_sim, tmp)
  }
  all_sim <- all_sim[-1,]
  
```


This runs the same model, except it assumes contact rates among those <20y increase 1.5-fold at time=100, using `c_scale_mat`.

```{r multiple_sim variable R0 variable c_scale_mat}

  age.limits = seq(0, 85, 5) 
  prop_symptomatic <- c(0.141, 0.106, 0.074, 0.184, 0.293, 0.357, 0.417, 0.431, 0.445, 
                        0.505, 0.565, 0.693, 0.816, 0.781, 0.749, 0.749, 0.505, 0.505)
  delta.t <- 1/1
  time <- seq(1,300,by = delta.t)
  
  all_prelim_info <- setup_seir_model(stoch = TRUE, R0 = 2, c_scale_vec = 1, prop_symptomatic = prop_symptomatic)
  Ncomp = all_prelim_info$Ncomp
  ICs = all_prelim_info$ICs
  params = list(C = all_prelim_info$C, 
                W = all_prelim_info$W, 
                beta0 = all_prelim_info$beta0, 
                beta1 = all_prelim_info$beta1, 
                phase = all_prelim_info$phase, 
                mu = all_prelim_info$mu, 
                v = all_prelim_info$v, 
                N=all_prelim_info$N, 
                gamma=all_prelim_info$gamma, 
                sigma = all_prelim_info$sigma, 
                prop_symptomatic=all_prelim_info$prop_symptomatic,
                sd.dw = all_prelim_info$sd.dw)
  
  c_scale_mat <- matrix(1, nrow=length(time), ncol=Ncomp)
  c_scale_mat[100:300, 1:4] <- 1.5
  
  all_sim <- matrix(NA,1,(Ncomp*7)+4)
  colnames(all_sim) <- c('run_index', 'time',
                         paste0("S", 1:Ncomp),
                         paste0("E", 1:Ncomp),
                         paste0("A", 1:Ncomp),
                         paste0("I", 1:Ncomp),
                         paste0("R", 1:Ncomp),
                         paste0("incid_A", 1:Ncomp),
                         paste0("incid_I", 1:Ncomp),
                         "R0",
                         "Reff")
  nsim <- 10
  
  for(n in 1:nsim){
    R0vec <- runif(length(time), min = 1.5, max = 2.5)
    tmp <- sair_step_variableR0(stoch = TRUE, stoch.init = TRUE, 
                                R0vec, Ncomp, ICs, params, time, delta.t,
                                c_scale_mat=c_scale_mat)
    run_index = rep(n, nrow(tmp))
    tmp <- cbind(run_index, tmp)
    all_sim <- rbind(all_sim, tmp)
  }
  all_sim <- all_sim[-1,]
  xx <- all_sim %>% select(starts_with("incid_I")) %>% rowSums()
  all_sim = cbind(all_sim, incidI=xx)
  
  plot(all_sim$R0, all_sim$Reff, pch=19, col=rgb(0,0,0,0.1), xlim=c(1.5, 2.5))
  ggplot(all_sim, aes(x=time, y=incidI, group=run_index)) + geom_line(alpha=0.3)
  
```


 -------------------------------

#### Transmission Model structure

**Model Equations:** Each of the age/other categories is denoted with subscript j. We will be using a stochastic model with difference equations as follows:

\[S_j(t) - S_j(t-1) = -e_j(t) \]
\[E_j(t) - E_j(t-1) = e_j(t) - i_j(t)\]
\[A_j(t) - A_j(t-1) =  (1-\rho) i_j(t) - r_{a,j}(t)\]
\[I_j(t) - I_j(t-1) =  \rho i_j(t) - r_{i,j}(t)\]
\[R_j(t) - R_j(t-1) = r_{a,j}(t) + r_{i,j}(t)\]

Here, $\rho$ is the symptomatic fraction, or the proportion of infections that will show clinical symptoms. The values $e$, $i$, and $r_a$, and $r_i$ are drawn randomly from a binomial distribution with daily probabilities:

\[e_j(t) \sim Binomial( S_j(t-1) ,\space 1 - \exp(\lambda_j(t-1))\]
\[i_j(t) \sim Binomial( E_j(t-1) ,\space \sigma)\]
\[r_{a,j}(t) \sim Binomial(A_j(t-1) ,\space \gamma)\]
\[r_{i,j}(t) \sim Binomial(I_j(t-1) ,\space \gamma)\]

Here, $\sigma$ is the daily probability of becoming infectious following exposure to SARS-CoV-2 and $\gamma$ is the daily probability of recovering once infectious. 

The force of infection, $\lambda$, is a function of the current prevalence of infectious individuals at each time step ($\sum_k A_k(t-1) + I_k(t-1)$); the contact matrix, $W_{jk}$, which determines the rate of contact between individuals in age class j and k; and  the underlying transmissibility $\beta_t$ of SARS-CoV-2 at time t. Here, we have allowed for seasonal variation in the transmissibility of SARS-CoV-2, though this seasonal transmissibility can be removed by setting $\beta_1 = 0$.

\[\beta_{t} = \beta_0 * (1+\beta_1*\cos(2\pi \frac{t}{365} - a)\]
\[\lambda_j(t) = \sum_k(\frac{\beta_t * W_{jk}*(A_k(t-1) + I_k(t-1)}{N_j} )\]

